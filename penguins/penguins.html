<!DOCTYPE html>
<html>
	<head>
		<title>Penguins</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
    background-color: #ffffff;
    margin: 0;
    overflow: hidden;
}

#css, #webgl {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
}

#css {
  background: black;
}

#webgl {
  pointer-events: none;
}


		</style>
	</head>
	<body>
		<script src="threejs/build/three.js"></script>
		<script src="threejs/examples/js/renderers/CSS3DRenderer.js"></script>
		<script src="threejs/examples/js/libs/inflate.min.js"></script>
		<script src="threejs/examples/js/loaders/FBXLoader.js"></script>
		<script src="threejs/examples/js/libs/dat.gui.min.js"></script>
		<script src="threejs/examples/js/WebGL.js"></script>
		
<!-- <div id="css"></div> -->
<div id="webgl"></div>

		<script>
			
			var camera, scene= new THREE.Scene(), renderer;
			var controls;
			
			var mouseX = 0;
			var mouseY = 0;

			var clock = new THREE.Clock();
			var delta;
			
			var player;
			
			var mouse = new THREE.Vector2();
			var mouseRaycaster = new THREE.Raycaster();
			var vec = new THREE.Vector3(); // create once and reuse
			var pos = new THREE.Vector3(); // create once and reuse
			
var plane = new THREE.Mesh( new THREE.PlaneGeometry( 3000, 300, 32 ), new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} ) );
plane.rotation.x = Math.PI / 2;
plane.visible = false;
			
			init();
			
			

			async function init() {

				//camera = new THREE.OrthographicCamera(-200,200,200,-200,1,5000);
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				
				camera.position.set( 0, 120, -150 );
				camera.lookAt( 0, 0, 0 );

				
				scene.add(plane);
				
				/*
				var image = document.createElement( 'img' );
				image.addEventListener( 'load', function () {
				}, false );
				image.src = 'threejs/examples/textures/sprite.png';
*/
				var fbxloader = new THREE.FBXLoader();
			   var object = await (new Promise(function(resolve, reject) {
				 fbxloader.load( 'models/Penguin.fbx', function ( loaded) {
				 loaded.material = new THREE.MeshToonMaterial( {
								color: 0xffffff,
								specular: 0x000000,
								reflectivity: 0,
								shininess: 0,
							} );
				loaded.scale.set(0.1,0.1,0.1);
				 resolve(loaded);
					/*
					object.traverse( function ( child ) {
						if ( child.isMesh ) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					} );
					*/
					});
					}));
					
					
							
						player = object;
						scene.add( object );

						var grid = new THREE.GridHelper( 1, 40, 0x0000ff, 0x808080 );
						grid.position.set(0,-1,0);
						scene.add( grid );
						
					    var sun = new THREE.DirectionalLight();
						sun.position.set(100,100,-100);
						scene.add( sun );
							
						var light = new THREE.AmbientLight( 0xffffff ); // soft white light
						scene.add( light );

        scene.add( new THREE.Mesh( new THREE.SphereGeometry( 5, 32, 32 ), new THREE.MeshBasicMaterial( {color: 0xffff00} ) ) );
		
				renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    //renderer.setClearColor( 0x000000, 0 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;
    //renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
    document.querySelector('#webgl').appendChild( renderer.domElement );
	
				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'mousedown', onDocumentMouseDown, false );
				window.addEventListener( 'mouseup', onDocumentMouseUp, false );

				render();
}

function onDocumentMouseDown(event) 
{
	
switch ( event.button ) {
    case 0: // left 
        break;
    case 1: // middle
        break;
    case 2: // right
        break;
}
    event.preventDefault();
}

function onDocumentMouseUp(event) 
{
	
switch ( event.button ) {
    case 0: // left 
        break;
    case 1: // middle
        break;
    case 2: // right
        break;
}
    event.preventDefault();
}

function onDocumentMouseMove( event ) {
mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	
		// update the picking ray with the camera and mouse position
	mouseRaycaster.setFromCamera( mouse, camera );

	// calculate objects intersecting the picking ray
	var intersects = [];

/*
var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   //x
                                        -( event.clientY / window.innerHeight ) * 2 + 1,  //y
                                        0.5 );                                            //z
        projector.unprojectVector( mouse3D, camera );   
        mouse3D.sub( camera.position );                
        mouse3D.normalize();
        var raycaster = new THREE.Raycaster( camera.position, mouse3D );
		
vec.set(
    ( event.clientX / window.innerWidth ) * 2 - 1,
    - ( event.clientY / window.innerHeight ) * 2 + 1,
    0.5 );

vec.unproject( camera );

vec.sub( camera.position ).normalize();

var distance = - camera.position.z / vec.z;

pos.copy( camera.position ).add( vec.multiplyScalar( distance ) );

    var intersects = raycaster.intersectObject( plane );

*/	
plane.raycast(mouseRaycaster,intersects);
pos = intersects[0].point;
	}

function render() {
			requestAnimationFrame( render );
			delta = clock.getDelta();
			
			update();
			
			renderer.render( scene, camera );

}

function update(){
player.rotation.y = Math.atan2( ( pos.x - player.position.x ), ( pos.z - player.position.z ) )+Math.PI;

}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}



		</script>
	</body>
</html>
